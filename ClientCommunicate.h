#ifndef CLIENTCOMMUNICATE_H
#define CLIENTCOMMUNICATE_H

#include <string>
#include <vector>
#include <sys/socket.h>

/**
 * @file ClientCommunicate.h
 * @brief Содержит объявление класса ClientCommunicate и структуры ParsedMessage.
 * @author Бренинг Иван
 * @date 13.12.24
 * @version 1.0
 */

/**
 * @brief Структура для хранения разобранного сообщения от клиента.
 *
 * Структура содержит поля для хранения логина, соли и хеша, извлеченных из сообщения клиента.
 * Эти данные используются для аутентификации пользователя.
 */
struct ParsedMessage {
    /**
     * @brief Логин пользователя.
     *
     * Строка, содержащая логин пользователя, извлеченный из сообщения клиента.
     */
    std::string login;
    /**
     * @brief Соль, используемая при хешировании пароля.
     *
     * Строка, содержащая соль, извлеченную из сообщения клиента.
     * Соль используется для повышения безопасности хранения паролей.
     */
    std::string salt;
    /**
     * @brief Хеш пароля пользователя.
     *
     * Строка, содержащая хеш пароля, извлеченный из сообщения клиента.
     * Хеш используется для проверки подлинности пользователя без необходимости хранения пароля в открытом виде.
     */
    std::string hash;
};

/**
 * @brief Класс ClientCommunicate отвечает за взаимодействие с клиентом.
 *
 * Класс предоставляет методы для парсинга сообщений от клиента и для обработки запросов клиента,
 * включая аутентификацию и обработку данных.
 */
class ClientCommunicate {
public:
    /**
     * @brief Осуществляет взаимодействие с клиентом.
     *
     * Функция принимает дескриптор сокета, имя файла базы данных пользователей и имя файла логов.
     *
     * Последовательность действий:
     * 1. Получает сообщение от клиента через сокет.
     * 2. Парсит полученное сообщение с помощью функции `parseMessage`.
     * 3. Если парсинг прошел успешно (структура `ParsedMessage` не пуста):
     *  - Выполняет аутентификацию пользователя с помощью класса `ConnectToBase`.
     *  - В случае успешной аутентификации:
     *      - Отправляет клиенту сообщение "OK".
     *      - Логирует успешную аутентификацию с помощью `Interface::logMessage`.
     *      - Вызывает функцию `processVectors` класса `Calculator` для обработки векторов от клиента.
     *      - Если при обработке векторов произошла ошибка, логирует ошибку с помощью `Interface::logError`.
     *  - В случае неудачи при аутентификации:
     *      - Отправляет клиенту сообщение "ERR".
     *      - Логирует ошибку аутентификации с помощью `Interface::logError`.
     * 4. Если парсинг сообщения не удался:
     *  - Логирует ошибку парсинга с помощью `Interface::logError`.
     *  - Отправляет клиенту сообщение "ERR".
     *
     * @param socket Дескриптор сокета для взаимодействия с клиентом.
     * @param userDbFileName Имя файла базы данных пользователей.
     * @param logFileName Имя файла логов.
     *
     * @note Функция не закрывает сокет после завершения работы.
     * @note Функция не обрабатывает ошибки отправки данных (`send`).
     * @note Функция предполагает, что файл базы данных пользователей и файл логов доступны для записи.
     */
    void communicate(int socket, const std::string& userDbFileName, const std::string& logFileName);

    /**
     * @brief Разбирает сообщение от клиента на составные части.
     *
     * Функция принимает строку сообщения от клиента и разбивает ее на логин, соль и хеш.
     * Предполагается, что сообщение имеет формат: `<логин><соль><хеш>`, где:
     * - длина соли фиксирована и равна 16 символам.
     * - длина хеша фиксирована и равна 40 символам.
     * - логин - это строка переменной длины, расположенная в начале сообщения.
     *
     * @param message Строка сообщения от клиента.
     * @return Структуру `ParsedMessage`, содержащую логин, соль и хеш. В случае ошибки парсинга (например, некорректный формат сообщения) возвращается пустая структура (все поля будут пустыми строками).
     *
     * @note Функция не проверяет корректность логина, соли и хеша (например, не проверяет, что хеш соответствует паролю и соли).
     * @note Функция использует фиксированные длины для соли и хеша. Изменение этих длин потребует изменения кода функции.
     */
    static ParsedMessage parseMessage(const std::string& message);

private:

};

#endif
