#ifndef INTERFACE_H
#define INTERFACE_H

#include <string>
#include <sstream>

/**
 * @file Interface.h
 * @brief Содержит объявление класса Interface.
 * @author Бренинг Иван
 * @date 13.12.24
 * @version 1.0
 */

/**
 * @brief Класс Interface предоставляет интерфейс для работы сервера,
 *        включая разбор аргументов командной строки, запуск сервера, логирование сообщений и ошибок.
 *
 * Класс предоставляет следующие статические методы:
 * - `printUsage`: выводит справку по использованию сервера.
 * - `logMessage`: логирует сообщение в файл лога.
 * - `logError`: логирует ошибку в файл лога и в поток ошибок.
 * - `runServer`: запускает сервер.
 * - `getParseResult`: разбирает аргументы командной строки, записывая ошибки в буфер.
 *
 * Класс хранит следующие статические данные:
 * - `logFileName`: имя файла лога.
 * - `userDbFileName`: имя файла базы данных пользователей.
 * - `port`: порт, на котором запускается сервер.
 */
class Interface {
public:
    /**
     * @brief Выводит справку по использованию сервера.
     *
     * Функция выводит в стандартный поток вывода (`std::cout`) информацию о том, как запустить сервер,
     * какие аргументы командной строки он принимает и какие значения по умолчанию используются для этих аргументов.
     */
    static void printUsage();

    /**
     * @brief Логирует сообщение в файл лога.
     *
     * Функция добавляет строку-разделитель с текущим временем, после чего записывает переданное
     * информационное сообщение в файл.
     *
     * @param logFileName Имя файла лога.
     * @param message Сообщение для логирования.
     *
     * @note Функция не обрабатывает ошибки открытия файла.
     */
    static void logMessage(const std::string& logFileName, const std::string& message);

    /**
     * @brief Логирует ошибку в файл лога и в поток ошибок.
     *
     * Функция добавляет строку-разделитель с текущим временем, после чего записывает переданное
     * сообщение об ошибке в файл. Также выводит сообщение в `std::cerr`.
     *
     * @param logFileName Имя файла лога.
     * @param message Сообщение об ошибке.
     * @param isCritical Флаг, указывающий, является ли ошибка критической.
     *
     * @note Функция не обрабатывает ошибки открытия файла.
     */
    static void logError(const std::string& logFileName, const std::string& message, bool isCritical);

    /**
     * @brief Запускает сервер.
     *
     * Функция осуществляет разбор командной строки, проверку доступности файлов базы данных и логов,
     * создание и настройку сокета, ожидание и обработку клиентских подключений.
     *
     * @param argc Количество аргументов командной строки.
     * @param argv Массив аргументов командной строки.
     * @return 0 в случае успешного выполнения, ненулевое значение в случае ошибки:
     *          - 1, если не удалось разобрать аргументы командной строки.
     *          - -1, если произошла ошибка при запуске сервера (например, не удалось создать сокет,
     *            привязать его к адресу или начать прослушивание).
     *
     * @note Функция использует `parseCommandLine` для разбора аргументов командной строки.
     * @note Функция использует `startServer` для запуска сервера.
     * @note Функция блокирует выполнение до тех пор, пока сервер не завершит работу.
     */
    static int runServer(int argc, char* argv[]);

    /**
     * @brief Разбирает аргументы командной строки и возвращает результат.
     *
     * Функция разбирает аргументы командной строки, устанавливая значения полей `logFileName`, `userDbFileName` и `port`.
     * Ошибки, возникшие при разборе, записываются в переданный буфер `buffer`.
     *
     * @param argc Количество аргументов командной строки.
     * @param argv Аргументы командной строки.
     * @param buffer Буфер для записи сообщений об ошибках.
     * @return 0 в случае успешного разбора аргументов, ненулевое значение в случае ошибки:
     *          - 1, если не удалось разобрать аргументы (например, пропущен обязательный аргумент).
     *          - -1, если передан некорректный номер порта.
     *
     * @note Функция использует `parseCommandLine` для разбора аргументов.
     * @note Функция перенаправляет `std::cerr` в `buffer` на время разбора аргументов.
     */
    static int getParseResult(int argc, char** argv, std::stringstream& buffer);

private:
    /**
     * @brief Имя файла лога.
     *
     * Статическая переменная, хранящая имя файла, в который будут записываться логи.
     * Значение устанавливается функцией `parseCommandLine`.
     */
    static std::string logFileName;

    /**
     * @brief Имя файла базы данных пользователей.
     *
     * Статическая переменная, хранящая имя файла, содержащего данные пользователей (логины и пароли).
     * Значение устанавливается функцией `parseCommandLine`.
     */
    static std::string userDbFileName;

    /**
     * @brief Порт, на котором сервер будет принимать соединения.
     *
     * Статическая переменная, хранящая номер порта, на котором сервер будет ожидать входящие соединения.
     * Значение устанавливается функцией `parseCommandLine`, значение по умолчанию - 33333.
     */
    static int port;

    /**
     * @brief Разбирает аргументы командной строки.
     *
     * Функция устанавливает значения полей `logFileName`, `userDbFileName` и `port` на основе переданных аргументов.
     *
     * @param argc Количество аргументов командной строки.
     * @param argv Массив аргументов командной строки.
     * @return 0 в случае успешного разбора, 1 в случае ошибки (например, пропущен обязательный аргумент или указан неверный формат).
     *
     * @note Функция использует `printUsage` для вывода справки по использованию в случае ошибки.
     * @note Функция проверяет, что обязательные аргументы `-l` и `-b` указаны.
     * @note Функция проверяет, что порт находится в допустимом диапазоне (1-65535).
     */
    static int parseCommandLine(int argc, char* argv[]);

    /**
     * @brief Запускает сервер и начинает прослушивание порта.
     *
     * Функция выполняет следующие действия:
     * 1. Проверяет доступность файлов логов и базы данных.
     * 2. Создает сокет.
     * 3. Устанавливает параметры сокета (переиспользование адреса и порта).
     * 4. Привязывает сокет к адресу и порту.
     * 5. Начинает прослушивание порта.
     * 6. В бесконечном цикле ожидает входящие соединения.
     * 7. При поступлении соединения принимает его.
     * 8. Создает объект `ClientCommunicate` для обработки клиента.
     * 9. Вызывает `ClientCommunicate::communicate` для взаимодействия с клиентом.
     * 10. Закрывает соединение с клиентом.
     * 11. Повторяет шаги 6-10.
     *
     * @return 0 в случае успешного запуска, -1 в случае ошибки на любом из этапов.
     *
     * @note Функция использует `Interface::logError` для логирования ошибок.
     * @note Функция использует `Interface::logMessage` для логирования информационных сообщений.
     * @note Функция использует `ClientCommunicate` для обработки клиентских подключений.
     * @note Функция блокирует выполнение, пока сервер не завершит работу.
     */
    static int startServer();
};

#endif
